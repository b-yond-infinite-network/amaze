-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : RESOURCE

-- trigger : ON_RESOURCE_BEFORE_INSERT
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_BEFORE_INSERT() RETURNS trigger AS
$BODY$
DECLARE	
	ID_COUNTER integer;
BEGIN

	ID_COUNTER := 1;

	-- find the first ID available in the RESOURCE table (avoid ID gap creation)	
	WHILE (EXISTS (SELECT RESOURCE_ID FROM public.RESOURCE WHERE RESOURCE_ID = ID_COUNTER)) LOOP 
		ID_COUNTER := ID_COUNTER + 1;
	END LOOP;

	IF (NEW.RESOURCE_ID <> ID_COUNTER) THEN 
	
		NEW.RESOURCE_ID = ID_COUNTER;
	
	END IF;

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_BEFORE_INSERT_RESOURCE_TRIGGER
	BEFORE INSERT
	ON public.RESOURCE
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_BEFORE_INSERT();

-- trigger : ON_RESOURCE_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN

	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following RESOURCE done with success in database.';

	-- log in audit table the resource creation
	INSERT INTO audits.AUDIT_RESOURCE (AUDIT_RESOURCE_TYPE, AUDIT_RESOURCE_DATE, AUDIT_RESOURCE_COMMENT, RESOURCE_ID, RESOURCE_NAME, RESOURCE_DESCRIPTION, RESOURCE_CRITICALITY, RESOURCE_QUANTITY_VALUE, RESOURCE_QUANTITY_DATE, RESOURCE_WARNING_LEVEL, RESOURCE_EMERGENCY_LEVEL)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.RESOURCE_ID, NEW.RESOURCE_NAME, NEW.RESOURCE_DESCRIPTION, NEW.RESOURCE_CRITICALITY, NEW.RESOURCE_QUANTITY_VALUE, NEW.RESOURCE_QUANTITY_DATE, NEW.RESOURCE_WARNING_LEVEL, NEW.RESOURCE_EMERGENCY_LEVEL);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_RESOURCE_TRIGGER
	AFTER INSERT
	ON public.RESOURCE
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_AFTER_INSERT_LOG();

-- trigger : ON_RESOURCE_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	RAISE LOG 'request of an RESOURCE deletion';
	RAISE LOG 'RESOURCE deletion already done in database';

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following RESOURCE done with success in database.';
		
	-- log in audit table the resource creation
	INSERT INTO audits.AUDIT_RESOURCE (AUDIT_RESOURCE_TYPE, AUDIT_RESOURCE_DATE, AUDIT_RESOURCE_COMMENT, RESOURCE_ID, RESOURCE_NAME, RESOURCE_DESCRIPTION, RESOURCE_CRITICALITY, RESOURCE_QUANTITY_VALUE, RESOURCE_QUANTITY_DATE, RESOURCE_WARNING_LEVEL, RESOURCE_EMERGENCY_LEVEL)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.RESOURCE_ID, OLD.RESOURCE_NAME, OLD.RESOURCE_DESCRIPTION, OLD.RESOURCE_CRITICALITY, OLD.RESOURCE_QUANTITY_VALUE, OLD.RESOURCE_QUANTITY_DATE, OLD.RESOURCE_WARNING_LEVEL, OLD.RESOURCE_EMERGENCY_LEVEL);
	
	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_RESOURCE_TRIGGER
	BEFORE DELETE
	ON public.RESOURCE
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_AFTER_DELETE_LOG();

-- trigger : ON_RESOURCE_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_RESOURCE_ID integer;
	LOCAL_RESOURCE_NAME varchar(50);
	LOCAL_RESOURCE_DESCRIPTION text;
	LOCAL_RESOURCE_CRITICALITY integer;
	LOCAL_RESOURCE_QUANTITY_VALUE float;
	LOCAL_RESOURCE_QUANTITY_DATE timestamp(6);
	LOCAL_RESOURCE_WARNING_LEVEL float;
	LOCAL_RESOURCE_EMERGENCY_LEVEL float;
	LOCAL_ELEMENT_ID integer;
BEGIN	
	
	-- get the variables of the updated resource
	LOCAL_RESOURCE_ID := NEW.RESOURCE_ID;
	LOCAL_RESOURCE_NAME := NEW.RESOURCE_NAME;
	LOCAL_RESOURCE_DESCRIPTION := NEW.RESOURCE_DESCRIPTION;
	LOCAL_RESOURCE_CRITICALITY := NEW.RESOURCE_CRITICALITY;
	LOCAL_RESOURCE_QUANTITY_VALUE := NEW.RESOURCE_QUANTITY_VALUE;
	LOCAL_RESOURCE_QUANTITY_DATE := NEW.RESOURCE_QUANTITY_DATE;
	LOCAL_RESOURCE_WARNING_LEVEL := NEW.RESOURCE_WARNING_LEVEL;
	LOCAL_RESOURCE_EMERGENCY_LEVEL := NEW.RESOURCE_EMERGENCY_LEVEL;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.RESOURCE_CRITICALITY = OLD.RESOURCE_CRITICALITY) THEN
		LOCAL_RESOURCE_CRITICALITY = null;	
	END IF;
	IF (NEW.RESOURCE_NAME = OLD.RESOURCE_NAME) THEN
		LOCAL_RESOURCE_NAME = null;	
	END IF;
	IF (NEW.RESOURCE_DESCRIPTION = OLD.RESOURCE_DESCRIPTION) THEN
		LOCAL_RESOURCE_DESCRIPTION = null;	
	END IF;
	IF (NEW.RESOURCE_QUANTITY_VALUE = OLD.RESOURCE_QUANTITY_VALUE) THEN
		LOCAL_RESOURCE_QUANTITY_VALUE = null;
	END IF;
	IF (NEW.RESOURCE_QUANTITY_DATE = OLD.RESOURCE_QUANTITY_DATE) THEN
		LOCAL_RESOURCE_QUANTITY_DATE = null;
	END IF;
	IF (NEW.RESOURCE_WARNING_LEVEL = OLD.RESOURCE_WARNING_LEVEL) THEN
		LOCAL_RESOURCE_WARNING_LEVEL = null;	
	END IF;
	IF (NEW.RESOURCE_EMERGENCY_LEVEL = OLD.RESOURCE_EMERGENCY_LEVEL) THEN
		LOCAL_RESOURCE_EMERGENCY_LEVEL = null;
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'RESOURCE updated with success with new values';
	
	-- log in audit table the USER_APPLICATION deletion		
	INSERT INTO audits.AUDIT_RESOURCE (AUDIT_RESOURCE_TYPE, AUDIT_RESOURCE_DATE, AUDIT_RESOURCE_COMMENT, RESOURCE_ID, RESOURCE_NAME, RESOURCE_DESCRIPTION, RESOURCE_CRITICALITY, RESOURCE_QUANTITY_VALUE, RESOURCE_QUANTITY_DATE, RESOURCE_WARNING_LEVEL, RESOURCE_EMERGENCY_LEVEL)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_RESOURCE_ID, LOCAL_RESOURCE_NAME, LOCAL_RESOURCE_DESCRIPTION,LOCAL_RESOURCE_CRITICALITY, LOCAL_RESOURCE_QUANTITY_VALUE, LOCAL_RESOURCE_QUANTITY_DATE, LOCAL_RESOURCE_WARNING_LEVEL, LOCAL_RESOURCE_EMERGENCY_LEVEL);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_RESOURCE_TRIGGER
	AFTER UPDATE
	ON public.RESOURCE
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_AFTER_UPDATE_LOG();

-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : RESOURCE_VARIATION

-- trigger : ON_RESOURCE_VARIATION_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_VARIATION_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following RESOURCE_VARIATION done with success in database.';
	
	-- log in audit table the resource_variation creation
	INSERT INTO audits.AUDIT_RESOURCE_VARIATION (AUDIT_RESOURCE_VARIATION_TYPE, AUDIT_RESOURCE_VARIATION_DATE, AUDIT_RESOURCE_VARIATION_COMMENT, RESOURCE_VARIATION_ID, RESOURCE_VARIATION_VALUE, RESOURCE_VARIATION_DATE, RESOURCE_VARIATION_APPLICATION, RESOURCE_VARIATION_DESCRIPTION, RESOURCE_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.RESOURCE_VARIATION_ID, NEW.RESOURCE_VARIATION_VALUE, NEW.RESOURCE_VARIATION_DATE, NEW.RESOURCE_VARIATION_APPLICATION, NEW.RESOURCE_VARIATION_DESCRIPTION, NEW.RESOURCE_ID);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_RESOURCE_VARIATION_TRIGGER
	AFTER INSERT
	ON public.RESOURCE_VARIATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_VARIATION_AFTER_INSERT_LOG();

-- trigger : ON_RESOURCE_VARIATION_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_VARIATION_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following RESOURCE_VARIATION done with success in database.';

	-- log in audit table the resource_variation deletion
	INSERT INTO audits.AUDIT_RESOURCE_VARIATION (AUDIT_RESOURCE_VARIATION_TYPE, AUDIT_RESOURCE_VARIATION_DATE, AUDIT_RESOURCE_VARIATION_COMMENT, RESOURCE_VARIATION_ID, RESOURCE_VARIATION_VALUE, RESOURCE_VARIATION_DATE, RESOURCE_VARIATION_APPLICATION, RESOURCE_VARIATION_DESCRIPTION, RESOURCE_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.RESOURCE_VARIATION_ID, OLD.RESOURCE_VARIATION_VALUE, OLD.RESOURCE_VARIATION_DATE, OLD.RESOURCE_VARIATION_APPLICATION, OLD.RESOURCE_VARIATION_DESCRIPTION, OLD.RESOURCE_ID);

	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_RESOURCE_VARIATION_TRIGGER
	BEFORE DELETE
	ON public.RESOURCE_VARIATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_VARIATION_AFTER_DELETE_LOG();

-- trigger : ON_RESOURCE_VARIATION_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_RESOURCE_VARIATION_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_RESOURCE_VARIATION_ID integer;
	LOCAL_RESOURCE_VARIATION_VALUE float;
	LOCAL_RESOURCE_VARIATION_DATE timestamp(6);
	LOCAL_RESOURCE_VARIATION_APPLICATION boolean;
	LOCAL_RESOURCE_VARIATION_DESCRIPTION text;
	LOCAL_RESOURCE_ID integer;
BEGIN	
	
	-- get the variables of the updated resource
	LOCAL_RESOURCE_VARIATION_ID := NEW.RESOURCE_VARIATION_ID;
	LOCAL_RESOURCE_VARIATION_VALUE := NEW.RESOURCE_VARIATION_VALUE;
	LOCAL_RESOURCE_VARIATION_DATE := NEW.RESOURCE_VARIATION_DATE;
	LOCAL_RESOURCE_VARIATION_APPLICATION := NEW.RESOURCE_VARIATION_APPLICATION;
	LOCAL_RESOURCE_VARIATION_DESCRIPTION := NEW.RESOURCE_VARIATION_DESCRIPTION;
	LOCAL_RESOURCE_ID := NEW.RESOURCE_ID;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.RESOURCE_VARIATION_VALUE = OLD.RESOURCE_VARIATION_VALUE) THEN
		LOCAL_RESOURCE_VARIATION_VALUE = null;	
	END IF;
	IF (NEW.RESOURCE_VARIATION_DATE = OLD.RESOURCE_VARIATION_DATE) THEN
		LOCAL_RESOURCE_VARIATION_DATE = null;
	END IF;
	IF (NEW.RESOURCE_VARIATION_APPLICATION = OLD.RESOURCE_VARIATION_APPLICATION) THEN
		LOCAL_RESOURCE_VARIATION_APPLICATION = null;
	END IF;
	IF (NEW.RESOURCE_VARIATION_DESCRIPTION = OLD.RESOURCE_VARIATION_DESCRIPTION) THEN
		LOCAL_RESOURCE_VARIATION_DESCRIPTION = null;	
	END IF;
	IF (NEW.RESOURCE_ID = OLD.RESOURCE_ID) THEN
		LOCAL_RESOURCE_ID = null;
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'RESOURCE VARIATION updated with success with new values';
	
	-- log in audit table the USER_APPLICATION deletion		
	INSERT INTO audits.AUDIT_RESOURCE_VARIATION (AUDIT_RESOURCE_VARIATION_TYPE, AUDIT_RESOURCE_VARIATION_DATE, AUDIT_RESOURCE_VARIATION_COMMENT, RESOURCE_VARIATION_ID, RESOURCE_VARIATION_VALUE, RESOURCE_VARIATION_DATE, RESOURCE_VARIATION_APPLICATION, RESOURCE_VARIATION_DESCRIPTION, RESOURCE_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_RESOURCE_VARIATION_ID, LOCAL_RESOURCE_VARIATION_VALUE, LOCAL_RESOURCE_VARIATION_DATE, LOCAL_RESOURCE_VARIATION_APPLICATION, LOCAL_RESOURCE_VARIATION_DESCRIPTION, LOCAL_RESOURCE_ID);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_RESOURCE_VARIATION_TRIGGER
	AFTER UPDATE
	ON public.RESOURCE_VARIATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_RESOURCE_VARIATION_AFTER_UPDATE_LOG();

-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : USER_APPLICATION

-- trigger : ON_USER_APPLICATION_BEFORE_INSERT
CREATE OR REPLACE FUNCTION public.ON_USER_APPLICATION_BEFORE_INSERT() RETURNS trigger AS
$BODY$
DECLARE	
	ID_COUNTER integer;
BEGIN

	ID_COUNTER := 1;

	-- find the first ID available in the USER_APPLICATION table (avoid ID gap creation)	
	WHILE (EXISTS (SELECT USER_APPLICATION_ID FROM public.USER_APPLICATION WHERE USER_APPLICATION_ID = ID_COUNTER)) LOOP 
		ID_COUNTER := ID_COUNTER + 1;
	END LOOP;

	IF (NEW.USER_APPLICATION_ID <> ID_COUNTER) THEN 
	
		NEW.USER_APPLICATION_ID = ID_COUNTER;
	
	END IF;

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_BEFORE_INSERT_USER_APPLICATION_TRIGGER
	BEFORE INSERT
	ON public.USER_APPLICATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_USER_APPLICATION_BEFORE_INSERT();

-- trigger : ON_USER_APPLICATION_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_USER_APPLICATION_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following USER_APPLICATION done with success in database.';
	
	-- log in audit table the USER_APPLICATION creation
	INSERT INTO audits.AUDIT_USER_APPLICATION (AUDIT_USER_APPLICATION_TYPE, AUDIT_USER_APPLICATION_DATE, AUDIT_USER_APPLICATION_COMMENT, USER_APPLICATION_ID, USER_APPLICATION_PROFILE)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.USER_APPLICATION_ID, NEW.USER_APPLICATION_PROFILE);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_USER_APPLICATION_TRIGGER
	AFTER INSERT
	ON public.USER_APPLICATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_USER_APPLICATION_AFTER_INSERT_LOG();

-- trigger : ON_USER_APPLICATION_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_USER_APPLICATION_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following USER_APPLICATION done with success in database.';

	-- log in audit table the USER_APPLICATION deletion
	INSERT INTO audits.AUDIT_USER_APPLICATION (AUDIT_USER_APPLICATION_TYPE, AUDIT_USER_APPLICATION_DATE, AUDIT_USER_APPLICATION_COMMENT, USER_APPLICATION_ID, USER_APPLICATION_PROFILE)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.USER_APPLICATION_ID, OLD.USER_APPLICATION_PROFILE);

	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_USER_APPLICATION_TRIGGER
	BEFORE DELETE
	ON public.USER_APPLICATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_USER_APPLICATION_AFTER_DELETE_LOG();

-- trigger : ON_USER_APPLICATION_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_USER_APPLICATION_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_USER_APPLICATION_ID integer;
	LOCAL_USER_APPLICATION_VALUE varchar(20);
BEGIN	
	
	-- get the variables of the updated resource
	LOCAL_USER_APPLICATION_ID := NEW.USER_APPLICATION_ID;
	LOCAL_USER_APPLICATION_VALUE := NEW.USER_APPLICATION_PROFILE;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.USER_APPLICATION_PROFILE = OLD.USER_APPLICATION_PROFILE) THEN
		LOCAL_USER_APPLICATION_VALUE = null;	
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'USER_APPLICATION updated with success with new values';
	
	-- log in audit table the USER_APPLICATION deletion		
	INSERT INTO audits.AUDIT_USER_APPLICATION (AUDIT_USER_APPLICATION_TYPE, AUDIT_USER_APPLICATION_DATE, AUDIT_USER_APPLICATION_COMMENT, USER_APPLICATION_ID, USER_APPLICATION_PROFILE)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_USER_APPLICATION_ID, LOCAL_USER_APPLICATION_VALUE);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_USER_APPLICATION_TRIGGER
	AFTER UPDATE
	ON public.USER_APPLICATION
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_USER_APPLICATION_AFTER_UPDATE_LOG();

-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : PIONEER

-- trigger : ON_PIONEER_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_PIONEER_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following PIONEER done with success in database.';

	-- log in audit table the pioneer creation
	INSERT INTO audits.AUDIT_PIONEER (AUDIT_PIONEER_TYPE, AUDIT_PIONEER_DATE, AUDIT_PIONEER_COMMENT, PIONEER_ID, PIONEER_LOGIN, PIONEER_PASSWORD, PIONEER_EMAIL, PIONEER_FIRST_NAME, PIONEER_LAST_NAME, PIONEER_BIRTHDATE, PIONEER_SEX, PIONEER_NOTATION, USER_APPLICATION_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.PIONEER_ID, NEW.PIONEER_LOGIN, NEW.PIONEER_PASSWORD, NEW.PIONEER_EMAIL, NEW.PIONEER_FIRST_NAME, NEW.PIONEER_LAST_NAME, NEW.PIONEER_BIRTHDATE, NEW.PIONEER_SEX, NEW.PIONEER_NOTATION, NEW.USER_APPLICATION_ID);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_PIONEER_TRIGGER
	AFTER INSERT
	ON public.PIONEER
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_PIONEER_AFTER_INSERT_LOG();

-- trigger : ON_PIONEER_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_PIONEER_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following PIONEER done with success in database.';
		
	-- log in audit table the pioneer deletion
	INSERT INTO audits.AUDIT_PIONEER (AUDIT_PIONEER_TYPE, AUDIT_PIONEER_DATE, AUDIT_PIONEER_COMMENT, PIONEER_ID, PIONEER_LOGIN, PIONEER_PASSWORD, PIONEER_EMAIL, PIONEER_FIRST_NAME, PIONEER_LAST_NAME, PIONEER_BIRTHDATE, PIONEER_SEX, PIONEER_NOTATION, USER_APPLICATION_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.PIONEER_ID, OLD.PIONEER_LOGIN, OLD.PIONEER_PASSWORD, OLD.PIONEER_EMAIL, OLD.PIONEER_FIRST_NAME, OLD.PIONEER_LAST_NAME, OLD.PIONEER_BIRTHDATE, OLD.PIONEER_SEX, OLD.PIONEER_NOTATION, OLD.USER_APPLICATION_ID);
	
	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_PIONEER_TRIGGER
	BEFORE DELETE
	ON public.PIONEER
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_PIONEER_AFTER_DELETE_LOG();

-- trigger : ON_PIONEER_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_PIONEER_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_PIONEER_ID integer;
	LOCAL_PIONEER_LOGIN varchar(20);
	LOCAL_PIONEER_PASSWORD varchar(100);
	LOCAL_PIONEER_EMAIL varchar(100);
	LOCAL_PIONEER_FIRST_NAME varchar(50);
	LOCAL_PIONEER_LAST_NAME varchar(50);
	LOCAL_PIONEER_BIRTHDATE timestamp(6);
	LOCAL_PIONEER_SEX boolean;
	LOCAL_PIONEER_NOTATION integer;
	LOCAL_USER_APPLICATION_ID integer;
BEGIN	
	
	-- get the variables of the updated pioneer
	LOCAL_PIONEER_ID := NEW.PIONEER_ID;
	LOCAL_PIONEER_LOGIN := NEW.PIONEER_LOGIN;
	LOCAL_PIONEER_PASSWORD := NEW.PIONEER_PASSWORD;
	LOCAL_PIONEER_EMAIL := NEW.PIONEER_EMAIL;
	LOCAL_PIONEER_FIRST_NAME := NEW.PIONEER_FIRST_NAME;
	LOCAL_PIONEER_LAST_NAME := NEW.PIONEER_LAST_NAME;
	LOCAL_PIONEER_BIRTHDATE := NEW.PIONEER_BIRTHDATE;
	LOCAL_PIONEER_SEX := NEW.PIONEER_SEX;
	LOCAL_PIONEER_NOTATION := NEW.PIONEER_NOTATION;
	LOCAL_USER_APPLICATION_ID := NEW.USER_APPLICATION_ID;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.PIONEER_LOGIN = OLD.PIONEER_LOGIN) THEN
		LOCAL_PIONEER_LOGIN = null;	
	END IF;
	IF (NEW.PIONEER_PASSWORD = OLD.PIONEER_PASSWORD) THEN
		LOCAL_PIONEER_PASSWORD = null;
	END IF;
	IF (NEW.PIONEER_EMAIL = OLD.PIONEER_EMAIL) THEN
		LOCAL_PIONEER_EMAIL = null;
	END IF;
	IF (NEW.PIONEER_FIRST_NAME = OLD.PIONEER_FIRST_NAME) THEN
		LOCAL_PIONEER_FIRST_NAME = null;	
	END IF;
	IF (NEW.PIONEER_LAST_NAME = OLD.PIONEER_LAST_NAME) THEN
		LOCAL_PIONEER_LAST_NAME = null;
	END IF;
	IF (NEW.PIONEER_BIRTHDATE = OLD.PIONEER_BIRTHDATE) THEN
		LOCAL_PIONEER_BIRTHDATE = null;
	END IF;
	IF (NEW.PIONEER_SEX = OLD.PIONEER_SEX) THEN
		LOCAL_PIONEER_SEX = null;
	END IF;
	IF (NEW.PIONEER_NOTATION = OLD.PIONEER_NOTATION) THEN
		LOCAL_PIONEER_NOTATION = null;	
	END IF;
	IF (NEW.USER_APPLICATION_ID = OLD.USER_APPLICATION_ID) THEN
		LOCAL_USER_APPLICATION_ID = null;
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'PIONEER updated with success with new values';

	-- log in audit table the USER_APPLICATION deletion		
	INSERT INTO audits.AUDIT_PIONEER (AUDIT_PIONEER_TYPE, AUDIT_PIONEER_DATE, AUDIT_PIONEER_COMMENT, PIONEER_ID, PIONEER_LOGIN, PIONEER_PASSWORD, PIONEER_EMAIL, PIONEER_FIRST_NAME, PIONEER_LAST_NAME, PIONEER_BIRTHDATE, PIONEER_SEX, PIONEER_NOTATION, USER_APPLICATION_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_PIONEER_ID, LOCAL_PIONEER_LOGIN, LOCAL_PIONEER_PASSWORD, LOCAL_PIONEER_EMAIL, LOCAL_PIONEER_FIRST_NAME, LOCAL_PIONEER_LAST_NAME, LOCAL_PIONEER_BIRTHDATE, LOCAL_PIONEER_SEX, LOCAL_PIONEER_NOTATION, LOCAL_USER_APPLICATION_ID);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_PIONEER_TRIGGER
	AFTER UPDATE
	ON public.PIONEER
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_PIONEER_AFTER_UPDATE_LOG();

-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : BABY_REQUEST

-- trigger : ON_BABY_REQUEST_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_REQUEST_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following BABY_REQUEST done with success in database.';

	-- log in audit table the baby request creation
	INSERT INTO audits.AUDIT_BABY_REQUEST (AUDIT_BABY_REQUEST_TYPE, AUDIT_BABY_REQUEST_DATE, AUDIT_BABY_REQUEST_COMMENT, REQUEST_ID, REQUEST_CREATE_DATE, REQUEST_SUBMIT_DATE, REQUEST_ACCEPT_DATE_1, REQUEST_ACCEPT_DATE_2, REQUEST_REFUSE_DATE_1, REQUEST_REFUSE_DATE_2, REQUEST_SCHEDULE_DATE, REQUEST_CLOSE_DATE, BABY_LOGIN, BABY_PASSWORD, BABY_EMAIL, BABY_FIRST_NAME, BABY_LAST_NAME, BABY_SEX)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.REQUEST_ID, NEW.REQUEST_CREATE_DATE, NEW.REQUEST_SUBMIT_DATE, NEW.REQUEST_ACCEPT_DATE_1, NEW.REQUEST_ACCEPT_DATE_2, NEW.REQUEST_REFUSE_DATE_1, NEW.REQUEST_REFUSE_DATE_2, NEW.REQUEST_SCHEDULE_DATE, NEW.REQUEST_CLOSE_DATE, NEW.BABY_LOGIN, NEW.BABY_PASSWORD, NEW.BABY_EMAIL, NEW.BABY_FIRST_NAME, NEW.BABY_LAST_NAME, NEW.BABY_SEX);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_BABY_REQUEST_TRIGGER
	AFTER INSERT
	ON public.BABY_REQUEST
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_REQUEST_AFTER_INSERT_LOG();

-- trigger : ON_BABY_REQUEST_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_REQUEST_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following BABY_REQUEST done with success in database.';

	-- log in audit table the BABY REQUEST deletion
	INSERT INTO audits.AUDIT_BABY_REQUEST (AUDIT_BABY_REQUEST_TYPE, AUDIT_BABY_REQUEST_DATE, AUDIT_BABY_REQUEST_COMMENT, REQUEST_ID, REQUEST_CREATE_DATE, REQUEST_SUBMIT_DATE, REQUEST_ACCEPT_DATE_1, REQUEST_ACCEPT_DATE_2, REQUEST_REFUSE_DATE_1, REQUEST_REFUSE_DATE_2, REQUEST_SCHEDULE_DATE, REQUEST_CLOSE_DATE, BABY_LOGIN, BABY_PASSWORD, BABY_EMAIL, BABY_FIRST_NAME, BABY_LAST_NAME, BABY_SEX)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.REQUEST_ID, OLD.REQUEST_CREATE_DATE, OLD.REQUEST_SUBMIT_DATE, OLD.REQUEST_ACCEPT_DATE_1, OLD.REQUEST_ACCEPT_DATE_2, OLD.REQUEST_REFUSE_DATE_1, OLD.REQUEST_REFUSE_DATE_2, OLD.REQUEST_SCHEDULE_DATE, OLD.REQUEST_CLOSE_DATE, OLD.BABY_LOGIN, OLD.BABY_PASSWORD, OLD.BABY_EMAIL, OLD.BABY_FIRST_NAME, OLD.BABY_LAST_NAME, OLD.BABY_SEX);
	
	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_BABY_REQUEST_TRIGGER
	BEFORE DELETE
	ON public.BABY_REQUEST
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_REQUEST_AFTER_DELETE_LOG();

-- trigger : ON_BABY_REQUEST_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_REQUEST_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_REQUEST_ID integer;
	LOCAL_REQUEST_CREATE_DATE timestamp(6);
	LOCAL_REQUEST_SUBMIT_DATE timestamp(6);
	LOCAL_REQUEST_ACCEPT_DATE_1 timestamp(6);
	LOCAL_REQUEST_ACCEPT_DATE_2 timestamp(6);
	LOCAL_REQUEST_REFUSE_DATE_1 timestamp(6);
	LOCAL_REQUEST_REFUSE_DATE_2 timestamp(6);
	LOCAL_REQUEST_SCHEDULE_DATE timestamp(6);
	LOCAL_REQUEST_CLOSE_DATE timestamp(6);
	LOCAL_BABY_LOGIN varchar(20);
	LOCAL_BABY_PASSWORD varchar(20);
	LOCAL_BABY_EMAIL varchar(100);
	LOCAL_BABY_FIRST_NAME varchar(50);
	LOCAL_BABY_LAST_NAME varchar(50);
	LOCAL_BABY_SEX boolean;
BEGIN	
	
	-- get the variables of the updated baby_request
	LOCAL_REQUEST_ID := NEW.REQUEST_ID;
	LOCAL_REQUEST_CREATE_DATE := NEW.REQUEST_CREATE_DATE;
	LOCAL_REQUEST_SUBMIT_DATE := NEW.REQUEST_SUBMIT_DATE;
	LOCAL_REQUEST_ACCEPT_DATE_1 := NEW.REQUEST_ACCEPT_DATE_1;
	LOCAL_REQUEST_ACCEPT_DATE_2 := NEW.REQUEST_ACCEPT_DATE_2;
	LOCAL_REQUEST_REFUSE_DATE_1 := NEW.REQUEST_REFUSE_DATE_1;
	LOCAL_REQUEST_REFUSE_DATE_2 := NEW.REQUEST_REFUSE_DATE_2;
	LOCAL_REQUEST_SCHEDULE_DATE := NEW.REQUEST_SCHEDULE_DATE;
	LOCAL_REQUEST_CLOSE_DATE := NEW.REQUEST_CLOSE_DATE;
	LOCAL_BABY_LOGIN := NEW.BABY_LOGIN;
	LOCAL_BABY_PASSWORD := NEW.BABY_PASSWORD;
	LOCAL_BABY_EMAIL := NEW.BABY_EMAIL;
	LOCAL_BABY_FIRST_NAME := NEW.BABY_FIRST_NAME;
	LOCAL_BABY_LAST_NAME := NEW.BABY_LAST_NAME;
	LOCAL_BABY_SEX := NEW.BABY_SEX;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.REQUEST_CREATE_DATE = OLD.REQUEST_CREATE_DATE) THEN
		LOCAL_REQUEST_CREATE_DATE = null;	
	END IF;
	IF (NEW.REQUEST_SUBMIT_DATE = OLD.REQUEST_SUBMIT_DATE) THEN
		LOCAL_REQUEST_SUBMIT_DATE = null;
	END IF;
	IF (NEW.REQUEST_ACCEPT_DATE_1 = OLD.REQUEST_ACCEPT_DATE_1) THEN
		LOCAL_REQUEST_ACCEPT_DATE_1 = null;
	END IF;
	IF (NEW.REQUEST_ACCEPT_DATE_2 = OLD.REQUEST_ACCEPT_DATE_2) THEN
		LOCAL_REQUEST_ACCEPT_DATE_2 = null;	
	END IF;
	IF (NEW.REQUEST_REFUSE_DATE_1 = OLD.REQUEST_REFUSE_DATE_1) THEN
		LOCAL_REQUEST_REFUSE_DATE_1 = null;
	END IF;
	IF (NEW.REQUEST_REFUSE_DATE_2 = OLD.REQUEST_REFUSE_DATE_2) THEN
		LOCAL_REQUEST_REFUSE_DATE_2 = null;
	END IF;
	IF (NEW.REQUEST_SCHEDULE_DATE = OLD.REQUEST_SCHEDULE_DATE) THEN
		LOCAL_REQUEST_SCHEDULE_DATE = null;
	END IF;
	IF (NEW.REQUEST_CLOSE_DATE = OLD.REQUEST_CLOSE_DATE) THEN
		LOCAL_REQUEST_CLOSE_DATE = null;	
	END IF;
	IF (NEW.BABY_LOGIN = OLD.BABY_LOGIN) THEN
		LOCAL_BABY_LOGIN = null;
	END IF;
	IF (NEW.BABY_PASSWORD = OLD.BABY_PASSWORD) THEN
		LOCAL_BABY_PASSWORD = null;
	END IF;
	IF (NEW.BABY_EMAIL = OLD.BABY_EMAIL) THEN
		LOCAL_BABY_EMAIL = null;
	END IF;
	IF (NEW.BABY_FIRST_NAME = OLD.BABY_FIRST_NAME) THEN
		LOCAL_BABY_FIRST_NAME = null;
	END IF;
	IF (NEW.BABY_LAST_NAME = OLD.BABY_LAST_NAME) THEN
		LOCAL_BABY_LAST_NAME = null;	
	END IF;
	IF (NEW.BABY_SEX = OLD.BABY_SEX) THEN
		LOCAL_BABY_SEX = null;
	END IF;

	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'BABY_REQUEST updated with success with new values';
	
	-- log in audit table the USER_APPLICATION deletion		
	INSERT INTO audits.AUDIT_BABY_REQUEST (AUDIT_BABY_REQUEST_TYPE, AUDIT_BABY_REQUEST_DATE, AUDIT_BABY_REQUEST_COMMENT, REQUEST_ID, REQUEST_CREATE_DATE, REQUEST_SUBMIT_DATE, REQUEST_ACCEPT_DATE_1, REQUEST_ACCEPT_DATE_2, REQUEST_REFUSE_DATE_1, REQUEST_REFUSE_DATE_2, REQUEST_SCHEDULE_DATE, REQUEST_CLOSE_DATE, BABY_LOGIN, BABY_PASSWORD, BABY_EMAIL, BABY_FIRST_NAME, BABY_LAST_NAME, BABY_SEX)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_REQUEST_ID, LOCAL_REQUEST_CREATE_DATE, LOCAL_REQUEST_SUBMIT_DATE, LOCAL_REQUEST_ACCEPT_DATE_1, LOCAL_REQUEST_ACCEPT_DATE_2, LOCAL_REQUEST_REFUSE_DATE_1, LOCAL_REQUEST_REFUSE_DATE_2, LOCAL_REQUEST_SCHEDULE_DATE, LOCAL_REQUEST_CLOSE_DATE, LOCAL_BABY_LOGIN, LOCAL_BABY_PASSWORD, LOCAL_BABY_EMAIL, LOCAL_BABY_FIRST_NAME, LOCAL_BABY_LAST_NAME, LOCAL_BABY_SEX);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_BABY_REQUEST_TRIGGER
	AFTER UPDATE
	ON public.BABY_REQUEST
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_REQUEST_AFTER_UPDATE_LOG();

-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : BABY_PARENT

-- trigger : ON_BABY_PARENT_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_PARENT_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following BABY_PARENT done with success in database.';
	
	-- log in audit table the BABY_PARENT creation
	INSERT INTO audits.AUDIT_BABY_PARENT (AUDIT_BABY_PARENT_TYPE, AUDIT_BABY_PARENT_DATE, AUDIT_BABY_PARENT_COMMENT, BABY_PARENT_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.BABY_PARENT_ID, NEW.PIONEER_ID, NEW.REQUEST_ID);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_BABY_PARENT_TRIGGER
	AFTER INSERT
	ON public.BABY_PARENT
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_PARENT_AFTER_INSERT_LOG();

-- trigger : ON_BABY_PARENT_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_PARENT_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following BABY_PARENT done with success in database.';
		
	-- log in audit table the BABY_REQUEST deletion
	INSERT INTO audits.AUDIT_BABY_PARENT (AUDIT_BABY_PARENT_TYPE, AUDIT_BABY_PARENT_DATE, AUDIT_BABY_PARENT_COMMENT, BABY_PARENT_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.BABY_PARENT_ID, OLD.PIONEER_ID, OLD.REQUEST_ID);

	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_BABY_PARENT_TRIGGER
	BEFORE DELETE
	ON public.BABY_PARENT
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_PARENT_AFTER_DELETE_LOG();

-- trigger : ON_BABY_PARENT_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_PARENT_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_BABY_PARENT_ID integer;
	LOCAL_PIONEER_ID integer;
	LOCAL_REQUEST_ID integer;
BEGIN	
	
	-- get the variables of the updated resource
	LOCAL_BABY_PARENT_ID := NEW.BABY_PARENT_ID;
	LOCAL_PIONEER_ID := NEW.PIONEER_ID;
	LOCAL_REQUEST_ID := NEW.REQUEST_ID;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.PIONEER_ID = OLD.PIONEER_ID) THEN
		LOCAL_PIONEER_ID = null;	
	END IF;
	IF (NEW.REQUEST_ID = OLD.REQUEST_ID) THEN
		LOCAL_REQUEST_ID = null;	
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'BABY_PARENT updated with success with new values';
	
	-- log in audit table the BABY_REQUEST update		
	INSERT INTO audits.AUDIT_BABY_PARENT (AUDIT_BABY_PARENT_TYPE, AUDIT_BABY_PARENT_DATE, AUDIT_BABY_PARENT_COMMENT, BABY_PARENT_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_BABY_PARENT_ID, LOCAL_PIONEER_ID, LOCAL_REQUEST_ID);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_BABY_PARENT_TRIGGER
	AFTER UPDATE
	ON public.BABY_PARENT
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_PARENT_AFTER_UPDATE_LOG();


-- ----------------------------------------------------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------------------------------------------
-- SCHEMA : public
-- TABLE : BABY_CHECKERS

-- trigger : ON_BABY_CHECKERS_AFTER_INSERT_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_CHECKERS_AFTER_INSERT_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN
	
	AUDIT_TYPE := 'create';	
	AUDIT_COMMENT := 'creation of the following BABY_CHECKERS done with success in database.';
	
	-- log in audit table the BABY_CHECKERS creation
	INSERT INTO audits.AUDIT_BABY_CHECKERS (AUDIT_BABY_CHECKERS_TYPE, AUDIT_BABY_CHECKERS_DATE, AUDIT_BABY_CHECKERS_COMMENT, BABY_CHECKERS_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, NEW.BABY_CHECKERS_ID, NEW.PIONEER_ID, NEW.REQUEST_ID);
	
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_INSERT_BABY_CHECKERS_TRIGGER
	AFTER INSERT
	ON public.BABY_CHECKERS
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_CHECKERS_AFTER_INSERT_LOG();

-- trigger : ON_BABY_CHECKERS_AFTER_DELETE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_CHECKERS_AFTER_DELETE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
BEGIN	

	AUDIT_TYPE := 'delete';	
	AUDIT_COMMENT := 'deletion of the following BABY_CHECKERS done with success in database.';
	
	-- log in audit table the BABY_REQUEST deletion
	INSERT INTO audits.AUDIT_BABY_CHECKERS (AUDIT_BABY_CHECKERS_TYPE, AUDIT_BABY_CHECKERS_DATE, AUDIT_BABY_CHECKERS_COMMENT, BABY_CHECKERS_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, OLD.BABY_CHECKERS_ID, OLD.PIONEER_ID, OLD.REQUEST_ID);

	RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;
	
CREATE TRIGGER ON_AFTER_DELETE_BABY_CHECKERS_TRIGGER
	BEFORE DELETE
	ON public.BABY_CHECKERS
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_CHECKERS_AFTER_DELETE_LOG();

-- trigger : ON_BABY_CHECKERS_AFTER_UPDATE_LOG
CREATE OR REPLACE FUNCTION public.ON_BABY_CHECKERS_AFTER_UPDATE_LOG() RETURNS trigger AS
$BODY$
DECLARE	
	AUDIT_TYPE varchar(10);
	AUDIT_COMMENT text;
	
	LOCAL_BABY_CHECKERS_ID integer;
	LOCAL_PIONEER_ID integer;
	LOCAL_REQUEST_ID integer;
BEGIN	
	
	-- get the variables of the updated resource
	LOCAL_BABY_CHECKERS_ID := NEW.BABY_CHECKERS_ID;
	LOCAL_PIONEER_ID := NEW.PIONEER_ID;
	LOCAL_REQUEST_ID := NEW.REQUEST_ID;

	-- check where are the differencies between the OLD and NEW values
	-- if they is no difference, -> set NULL
	IF (NEW.PIONEER_ID = OLD.PIONEER_ID) THEN
		LOCAL_PIONEER_ID = null;	
	END IF;
	IF (NEW.REQUEST_ID = OLD.REQUEST_ID) THEN
		LOCAL_REQUEST_ID = null;	
	END IF;
	
	AUDIT_TYPE := 'update';	
	AUDIT_COMMENT := 'BABY_CHECKERS updated with success with new values';
	
	-- log in audit table the BABY_REQUEST update		
	INSERT INTO audits.AUDIT_BABY_CHECKERS (AUDIT_BABY_CHECKERS_TYPE, AUDIT_BABY_CHECKERS_DATE, AUDIT_BABY_CHECKERS_COMMENT, BABY_CHECKERS_ID, PIONEER_ID, REQUEST_ID)
	VALUES(AUDIT_TYPE, now(), AUDIT_COMMENT, LOCAL_BABY_CHECKERS_ID, LOCAL_PIONEER_ID, LOCAL_REQUEST_ID);

	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER ON_AFTER_UPDATE_BABY_CHECKERS_TRIGGER
	AFTER UPDATE
	ON public.BABY_CHECKERS
	FOR EACH ROW
	EXECUTE PROCEDURE public.ON_BABY_CHECKERS_AFTER_UPDATE_LOG();